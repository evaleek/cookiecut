<!DOCTYPE html>
<html lang="en" style="height:100%;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CookieCut</title>
    <style>
        #levels {
            display: flex;
            flex-direction: column;
        }

        .level {
            display: flex;
            flex-direction: row;
        }

        .level-glyph-input {
            text-align: center;
        }
    </style>
</head>
<body>
    <script type="module" src="./cookiecut.js"></script>
    <script type="module">
        import * as cc from './cookiecut.js';

        // TODO show failure in UI
        if (!cc.supported()) throw new Error("WebGL is not supported");

        const processContext = new cc.Context(document.getElementById("webgl-canvas"));
        const glyphContext = document.getElementById("glyph-canvas").getContext("2d");
        const previewContext = document.getElementById("preview-canvas").getContext("2d");

        let image;
        let imageMeans;
        let imageMeansDirty = true;
        let glyphThumbnailsDirty = true;

        function refreshPreview() {
            let cellSize;

            if (imageMeansDirty) {
                if (image) {
                    cellSize ??= getCellSize();
                    imageMeans = cc.computeCellMeans(
                        processContext,
                        new cc.ProcessingBuffer(
                            processContext.gl,
                            cellSize,
                            getCellCount(cellSize, image),
                            true
                        ),
                        image
                    ); // TODO masks from where that lives on the DOM
                } else {
                    imageMeans = null;
                }
                imageMeansDirty = false;
            }

            if (imageMeans) {
                cellSize ??= getCellSize();
                // TODO keep preview canvas at a constant resolution,
                // but adjust *aspect ratio* to match new image
                previewContext.canvas.width = cellSize[0] * imageMeans[0].length;
                previewContext.canvas.height = cellSize[1] * imageMeans.length;
                cc.drawValueDots(previewContext, imageMeans, getPixelValuer());
            } else {
                previewContext.canvas.width = 100;
                previewContext.canvas.height = 100;
                previewContext.clearRect(0, 0, previewContext.canvas.width,
                                               previewContext.canvas.height);
            }

            if (glyphThumbnailsDirty) {
                const glyphs = getLevels().map((level) => level.glyphs).flat();
                if (glyphs.length) cc.setGlyphImgs(
                    glyphs.map((glyph) => [glyph.character,
                                           glyph.node.querySelector("img")]),
                    getCellSize(),
                    'black', // TODO glyph color?
                    glyphContext
                );
                glyphThumbnailsDirty = false;
            }
        }

        function clearOutput() {
            const output = document.getElementById("output");
            output.rows = 8;
            output.cols = 8;
            output.value = '';
        }

        function refreshOutput() {
            const levels = getLevels();
            const chars = [...new Set(levels.map((level) =>
                level.glyphs.map((glyph) => glyph.character)).flat())];

            if ((!image) || chars.length == 0) {
                clearOutput();
                return;
            }

            if (!imageMeans) throw new Error("missing image means at refresh");

            const imageDct = cc.computeImageDct(
                processContext,
                new cc.ProcessingBuffer(
                    processContext.gl,
                    getCellSize(),
                    [imageMeans[0].length, imageMeans.length],
                    true
                ),
                image
            );

            const charDcts = cc.computeGlyphDcts(
                processContext,
                getCellSize(),
                chars,
                glyphContext
            );
            const dctLookup = new Map(chars.map((c, i) => [c, charDcts[i]]));

            const thresholds = levels.map((level) => level.range.valueAsNumber);
            const glyphLists = levels.map((level) =>
                level.glyphs.map((glyph) => glyph.character));

            const valuer = getPixelValuer();

            const outputGrid = imageDct.map((row, rowIdx) => row.map((dct, colIdx) => {
                const mean = imageMeans[rowIdx][colIdx];
                const value = valuer(mean);

                let levelIdx = 0;
                for (const threshold of thresholds) {
                    if (value > threshold) {
                        levelIdx += 1;
                    } else {
                        break;
                    }
                }
                if (levelIdx >= levels.length) return ' ';

                const glyphList = glyphLists[levelIdx].map((glyph) => glyph ?? ' ');

                if (glyphList.length == 1) {
                    return glyphList[0];
                } else if (glyphList.length == 0) {
                    return ' ';
                }

                const matchIdx = glyphList
                    .map((glyph) => cc.dctDistance(dct, dctLookup.get(glyph)))
                    .reduce((leastIdx, dist, curIdx, distances) =>
                        (dist < distances[leastIdx]) ? curIdx : leastIdx, 0);

                return glyphList[matchIdx];
            }));

            const output = document.getElementById("output");
            output.rows = outputGrid.length;
            output.cols = outputGrid[0].length;
            output.value = outputGrid.map((row) => row.join('')).join('\n');
        }

        function setImage(img) {
            const subdivInput = document.getElementById("subdivisions-input");
            if (img) {
                image = new cc.Image(processContext, img);
                const w = image.size[0];
                const h = image.size[1];

                if (image.textureSizeClipped) {
                    // TODO notify user in DOM
                    const m = processContext.imageSizeLimit;
                    console.warn(`image size ${w}x${h} exceeds the supported maximum ${m}x${m}`);
                }

                const minSubdivisions = 4;
                const maxSubdivisions = 128;
                const imgSize = Math.min(w, h);
                const maxCellSize = Math.round(imgSize / minSubdivisions);
                const minCellSize = Math.max(
                    cc.glyphPxMinimum,
                    Math.round(imgSize / maxSubdivisions)
                );

                subdivInput.disabled = false;
                subdivInput.min = minCellSize;
                subdivInput.max = maxCellSize;
            } else {
                image = null;

                subdivInput.disabled = true;
            }
            imageMeansDirty = true;
            refreshPreview();
        }

        function onImageUpload() {
            const userImage = document.getElementById("user-image");
            const imageUpload = document.getElementById("user-image-upload");
            const len = imageUpload.files.length;
            if (len == 1 && imageUpload.files[0].type.startsWith("image/")) {
                // TODO handle if image is too big
                const reader = new FileReader();
                reader.onload = (e) => {
                    userImage.src = e.target.result;
                    userImage.onload = () => setImage(userImage);
                    userImage.onerror = () => setImage(null);
                };
                reader.readAsDataURL(imageUpload.files[0]);
            } else {
                userImage.src = '';
                setImage(null);
                if (len > 1) {
                    console.error("unexpected file upload count " + len);
                }
            }
        }

        function onHoverCellSize(e) {
            if (image) {
                // TODO inherit from style
                const gridColor = 'darkgray';
                const cellPreviewPortion = 0.8;
                const cellPreviewRadius = 0.68;
                const ctx = previewContext;
                const width = ctx.canvas.width;
                const height = ctx.canvas.height;
                const cellSize = computeCellSize(e.target.valueAsNumber);
                const cellCount = getCellCount(cellSize, image);
                const xStride = width/cellCount[0];
                const yStride = height/cellCount[1];
                const squareSize = Math.min(xStride, yStride) * cellPreviewPortion;
                const halfSquare = 0.5*squareSize;
                const radius = cellPreviewRadius * halfSquare;

                document.querySelectorAll(".cell-size-width-display")
                    .forEach((node) => { node.innerHTML = cellSize[0].toString(); });
                document.querySelectorAll(".cell-size-height-display")
                    .forEach((node) => { node.innerHTML = cellSize[1].toString(); });
                document.querySelectorAll(".cell-count-width-display")
                    .forEach((node) => { node.innerHTML = cellCount[0].toString(); });
                document.querySelectorAll(".cell-count-height-display")
                    .forEach((node) => { node.innerHTML = cellCount[1].toString(); });

                ctx.fillStyle = gridColor;
                ctx.clearRect(0, 0, width, height);
                ctx.beginPath();

                let col;
                for (let row = 0; row < cellCount[1]; row++) {
                    for (col = 0; col < cellCount[0]; col++) {
                        const x = (col+0.5)*xStride;
                        const y = (row+0.5)*yStride;
                        ctx.roundRect(
                            x-halfSquare,
                            y-halfSquare,
                            squareSize,
                            squareSize,
                            radius
                        );
                    }
                }

                ctx.fill();
            } else {
                console.error("cell size input hover without a set image");
            }
        }

        function onSetCellSize(e) {
            imageMeansDirty = true;
            glyphThumbnailsDirty = true;
            refreshPreview();
        }

        function getCellSize() {
            const subdivInput = document.getElementById("subdivisions-input");
            if (subdivInput.disabled) {
                console.error("request for unenabled cell size");
            }
            return computeCellSize(subdivInput.valueAsNumber);
        }

        function computeCellSize(inputValue) {
            return [
                Math.round(inputValue),
                Math.round(inputValue)
            ];
        }

        function getCellCount(cellSize, image) {
            return [
                Math.ceil(image.size[0] / cellSize[0]),
                Math.ceil(image.size[1] / cellSize[1])
            ];
        }

        function getPixelValuer() {
            const check = document.querySelector('input[name="value-choice"]:checked').value;
            switch (check) {
                case "lights":
                    return (rgba) => ((rgba[0]+rgba[1]+rgba[2])/3) * rgba[3];
                case "darks":
                    return (rgba) => (1-((rgba[0]+rgba[1]+rgba[2])/3)) * rgba[3];
                case null:
                    throw new Error("no value type checked at pixel valuation");
                default:
                    throw new Error(`unrecognized pixel valuation \"${check}\"`);
            }
        }

        function getLevelNodes() {
            return Array.from(document.getElementById("levels").children)
                .filter((element) => element.classList.contains("level"));
        }

        function getLevels() {
            return getLevelNodes().map((element) => ({
                range: element.querySelector("input[type=\"range\"].level-range"),
                glyphs: Array.from(element.querySelector(".level-glyph-list").children)
                            .filter((child) => child.classList.contains("level-glyph"))
                            .map((child) => ({
                                node: child,
                                character: child.characterValue
                            }))
            }));
        }

        function onAddLevel() {
            const level = document.createElement("div");
            level.classList.add("level");
            level.append(document.getElementById("level-template")
                .content.cloneNode(true));

            const range = level.querySelector("input[type=\"range\"].level-range");
            const ranges = getLevels().map((l) => l.range);
            if (ranges.length > 0) {
                const lastRange = ranges.at(-1);
                const floor = Number(lastRange.value);
                const size = Math.min(Math.round((1-floor)*100), 100);

                range.style.inlineSize = `${size}%`;
                range.setAttribute("min", floor);
                range.value = 1.0;

                range.inputListener = (e) => {
                    const newFloor = Number(e.target.value);
                    const newSize = Math.min(Math.round((1.0 - newFloor)*100), 100);
                    range.style.inlineSize = `${newSize}%`;
                    range.setAttribute("min", newFloor);
                    range.dispatchEvent(new Event("cascade"));
                };
                lastRange.addEventListener("input", range.inputListener);
                lastRange.addEventListener("cascade", range.inputListener);
            } else {
                range.style.inlineSize = "100%";
                range.setAttribute("min", 0);
                range.value = 1.0;
            }

            const prevRange = ranges.at(-1);
            // TODO inherit from style
            const highlightColor = 'red';
            const hoverHighlightColor = 'pink';

            const highlightCells = (c) => ((e) => {
                if (imageMeans) cc.drawValueDots(
                    previewContext,
                    imageMeans,
                    getPixelValuer(),
                    null, [
                        prevRange?.valueAsNumber ?? 0,
                        e.target.valueAsNumber
                    ], c
                );
            });
            const clearCells = () => {
                if (imageMeans) cc.drawValueDots(previewContext, imageMeans, getPixelValuer())
            };
            range.addEventListener("input", highlightCells(highlightColor));
            range.addEventListener("mousedown", highlightCells(highlightColor));
            range.addEventListener("mouseenter", highlightCells(hoverHighlightColor));
            range.addEventListener("mouseup", highlightCells(hoverHighlightColor));
            range.addEventListener("mouseleave", clearCells);

            const addGlyphButton = level.querySelector(".level-glyph-control > .level-add-glyph");
            const removeGlyphButton = level.querySelector(".level-glyph-control > .level-remove-glyph");
            removeGlyphButton.disabled = true;
            addGlyphButton.addEventListener("click", () => {
                const glyph = document.createElement("div");
                glyph.classList.add("level-glyph");
                glyph.append(document.getElementById("level-glyph-template")
                    .content.cloneNode(true));
                glyph.characterValue = null;
                level.querySelector(".level-glyph-list").appendChild(glyph);
                removeGlyphButton.disabled = false;

                const img = glyph.querySelector("img");
                glyph.querySelector(".level-glyph-input")
                    .addEventListener("input", (e) => {
                        if (e.target.value == ' ' || e.target.value == '') {
                            glyph.characterValue = null;
                            img.src = '';
                        } else if (e.target.value.length == 1) {
                            glyph.characterValue = e.target.value;
                            img.src = cc.glyphDataUrl(
                                e.target.value,
                                getCellSize(),
                                'black', // TODO glyph color?
                                glyphContext
                            );
                        } else {
                            console.error(`unexpected glyph input string \"${e.target.value}\"`);
                        }
                    });
            });
            removeGlyphButton.addEventListener("click", () => {
                const list = level.querySelector(".level-glyph-list");
                const glyphs = Array.from(list.children)
                    .filter((element) => element.classList.contains("level-glyph"));
                if (glyphs.length > 0) {
                    if (glyphs.length == 1) removeGlyphButton.disabled = true;
                    list.removeChild(glyphs.at(-1));
                }
            });

            document.getElementById("levels").appendChild(level);
        }

        function onRemoveLevel() {
            const levelNodes = getLevelNodes();

            if (levelNodes.length > 0) {
                const last = levelNodes.at(-1);
                const lastRange = last.querySelector("input[type=\"range\"].level-range");
                if (lastRange.inputListener) {
                    const secondToLast = levelNodes.at(-2);
                    if (secondToLast) {
                        secondToLast.querySelector("input[type=\"range\"].level-range")
                            .removeEventListener("input", lastRange.inputListener);
                    } else {
                        console.error("expected removed level node to have " +
                            "a parent with the matching input listener");
                    }
                } else if (levelNodes.length != 1) {
                    console.error("expected removed level node to have " +
                        "an input listener");
                }

                document.getElementById("levels").removeChild(last);
            }
        }

        function onChangeLevels() {
            if (getLevelNodes()?.length > 0) {
                removeLevel.disabled = false;
            } else {
                removeLevel.disabled = true;
            }
        }

        function onChangeValueChoice() {
            imageMeansDirty = true;
            refreshPreview();
        }

        document.getElementById("user-image-upload").addEventListener("change", onImageUpload);
        document.getElementById("subdivisions-input").addEventListener("input", onHoverCellSize);
        document.getElementById("subdivisions-input").addEventListener("change", onSetCellSize);
        document.getElementById("process-output").addEventListener("click", refreshOutput);

        const addLevel = document.getElementById("add-level");
        const removeLevel = document.getElementById("remove-level");
        addLevel.addEventListener("click", onAddLevel);
        addLevel.addEventListener("click", onChangeLevels);
        removeLevel.addEventListener("click", onRemoveLevel);
        removeLevel.addEventListener("click", onChangeLevels);
        document.querySelectorAll('input[name="value-choice"]')
            .forEach((node) =>
                node.addEventListener("change", onChangeValueChoice));

        onChangeLevels();
        clearOutput();
        onImageUpload();
    </script>
    <canvas id="webgl-canvas" style="display: none;"></canvas>
    <canvas id="glyph-canvas" style="display: none;"></canvas>
    <img id="user-image">
    <input type="range" id="subdivisions-input" step="1" disabled />
    <span class="cell-size-width-display"></span>
    <span class="cell-size-height-display"></span>
    <span class="cell-count-width-display"></span>
    <span class="cell-count-height-display"></span>
    <input type="file" id="user-image-upload" accept="image/*" />
    <canvas id="preview-canvas"></canvas>
    <div>
        <input type="radio" id="value-lights-choice" name="value-choice" value="lights" checked />
        <label for="value-lights-choice">Value lights</label>
        <input type="radio" id="value-darks-choice" name="value-choice" value="darks" />
        <label for="value-darks-choice">Value darks</label>
    </div>
    <div id="levels-control">
        <input type="button" id="remove-level" value="Remove level" />
        <input type="button" id="add-level" value="Add level" />
    </div>
    <div id="levels">
        <template id="level-template">
            <input type="range" class="level-range" step="any" max="1" style="inline-size:100%;" />
            <div class="level-glyph-control">
                <input type="button" class="level-remove-glyph" value="Remove glyph" />
                <input type="button" class="level-add-glyph" value="Add glyph" />
            </div>
            <div class="level-glyph-list">
                <template id="level-glyph-template">
                    <img>
                    <input type="text" class="level-glyph-input" maxlength="1" size="1" />
                </template>
            </div>
        </template>
    </div>
    <input type="button" id="process-output" value="Process" />
    <textarea id="output" readonly></textarea>
</body>
</html>
