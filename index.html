<!DOCTYPE html>
<html lang="en" style="height:100%;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CookieCut</title>
    <link href="./cookiecut.css" rel="stylesheet">
</head>
<body>
    <script type="module" src="./cookiecut.js"></script>
    <script type="module">
        import * as cc from './cookiecut.js';

        // TODO show failure in UI
        if (!cc.supported()) throw new Error("WebGL is not supported");

        const processContext = new cc.Context(document.getElementById("webgl-canvas"));
        const glyphContext = document.getElementById("glyph-canvas").getContext("2d");
        const previewContext = document.getElementById("preview-canvas").getContext("2d");

        let image;
        let fullImage;
        let imageMeans;
        let imageEdges;
        let imageDataDirty = true;

        function refreshPreview() {
            let cellSize;

            if (imageDataDirty) {
                if (fullImage) {
                    cellSize ??= getCellSize();
                    const processBuffer = new cc.ProcessingBuffer(
                        processContext.gl,
                        cellSize,
                        getCellCount(cellSize, fullImage),
                        true
                    );

                    {
                        const masks = getMasks();
                        imageMeans = cc.computeCellMeans(
                            processContext,
                            processBuffer,
                            fullImage,
                            (masks.length) ? masks.map((mask) => mask.rgb) : null
                        );
                    }

                    {
                        const edgeCells = cc.computeImageSobel(
                            processContext,
                            processBuffer,
                            fullImage
                        );
                        const invSqrt2 = 1 / Math.sqrt(2);
                        imageEdges = edgeCells.map((row) => row.map((block) => {
                            const magnitudes = block.flat()
                                .map((gradient) => invSqrt2*gradient.magnitude);
                            return magnitudes.reduce((a,b) => a+b)
                                / magnitudes.length;
                        }));
                    }

                    {
                        const means = imageMeans.flat(1);
                        const bucketCount = 64; // TODO dynamic?
                        const buckets = cc.bucketPixels(means, bucketCount, getPixelValuer());
                        const ctx = glyphContext;
                        // TODO query for proper width and height
                        ctx.canvas.width = 300;
                        ctx.canvas.height = 150;

                        const maxBucketSize = buckets
                            .map((bucket) => bucket.length)
                            .reduce((a, b) => Math.max(a, b));
                        const barWidth = ctx.canvas.width / buckets.length;

                        for (const [barIdx, bucket] of buckets.entries()) {
                            if (bucket.length) {
                                const barHeight = ctx.canvas.height*(bucket.length)/maxBucketSize;
                                const x = barIdx * barWidth;
                                ctx.fillStyle = cc.pixelToColor(cc.pixelMean(bucket));
                                ctx.fillRect(x, 0, barWidth, barHeight);
                            }
                        }

                        document.getElementById("level-histogram").src =
                            ctx.canvas.toDataURL();
                    }
                } else {
                    imageMeans = null;
                    document.getElementById("level-histogram").src = '';
                }
                imageDataDirty = false;
            }

            if (imageMeans) {
                cellSize ??= getCellSize();
                const imgWidth = cellSize[0] * imageMeans[0].length;
                const imgHeight = cellSize[1] * imageMeans.length;
                const container = previewContext.canvas.parentNode;
                if (container.classList?.contains("preview-container")) {
                    const imgAspect = imgWidth/imgHeight;
                    previewContext.canvas.width = container.offsetWidth;
                    previewContext.canvas.height = container.offsetWidth / imgAspect
                } else {
                    previewContext.canvas.height = imgWidth;
                    previewContext.canvas.width = imgHeight;
                }
                cc.drawValueDots(previewContext, imageMeans, getPixelValuer());
            } else {
                previewContext.canvas.width = 1;
                previewContext.canvas.height = 1;
                previewContext.clearRect(0, 0, previewContext.canvas.width,
                                               previewContext.canvas.height);
            }
        }

        function clearOutput() {
            const output = document.getElementById("output");
            output.rows = 8;
            output.cols = 8;
            output.value = '';
        }

        function refreshOutput() {
            const levels = getLevels();
            const chars = [...new Set(levels.map((level) => level.glyphs).flat())];

            if ((!image) || chars.length == 0) {
                clearOutput();
                return;
            }

            if (!imageMeans) throw new Error("missing image means at refresh");
            if ( ( image.cellCount[0] != imageMeans[0].length ) ||
                 ( image.cellCount[1] != imageMeans.length )
            ) throw new Error("imageMeans cell count does not match the image");

            const imageDct = cc.computeImageDct(processContext, image);

            const charDcts = cc.computeGlyphDcts(
                processContext,
                image.cellSize,
                document.querySelector('input[name="value-choice"]:checked').value,
                chars,
                glyphContext
            );
            const dctLookup = new Map(chars.map((c, i) => [c, charDcts[i]]));

            const thresholds = levels.map((level) => level.range.valueAsNumber);
            const glyphLists = levels.map((level) => level.glyphs);

            const valuer = getPixelValuer();

            const outputGrid = imageDct.map((row, rowIdx) => row.map((dct, colIdx) => {
                const mean = imageMeans[rowIdx][colIdx];
                const value = valuer(mean);

                let levelIdx = 0;
                for (const threshold of thresholds) {
                    if (value > threshold) {
                        levelIdx += 1;
                    } else {
                        break;
                    }
                }
                if (levelIdx >= levels.length) return ' ';

                const glyphList = glyphLists[levelIdx].map((glyph) => glyph ?? ' ');

                if (glyphList.length == 1) {
                    return glyphList[0];
                } else if (glyphList.length == 0) {
                    return ' ';
                }

                const matchIdx = glyphList
                    .map((glyph) => cc.dctGradientDistance(dct, dctLookup.get(glyph)))
                    .reduce((leastIdx, dist, curIdx, distances) =>
                        (dist < distances[leastIdx]) ? curIdx : leastIdx, 0);

                return glyphList[matchIdx];
            }));

            const output = document.getElementById("output");
            output.rows = outputGrid.length;
            output.cols = outputGrid[0].length;
            output.value = outputGrid.map((row) => row.join('')).join('\n');
        }

        function updateCellSizePreview(cellSize, cellCount) {
            document.querySelectorAll(".cell-size-width-display")
                .forEach((node) => { node.innerHTML = cellSize[0].toString(); });
            document.querySelectorAll(".cell-size-height-display")
                .forEach((node) => { node.innerHTML = cellSize[1].toString(); });
            document.querySelectorAll(".cell-count-width-display")
                .forEach((node) => { node.innerHTML = cellCount[0].toString(); });
            document.querySelectorAll(".cell-count-height-display")
                .forEach((node) => { node.innerHTML = cellCount[1].toString(); });
        }

        function setImage(img) {
            const subdivInput = document.getElementById("subdivisions-input");
            if (img) {
                fullImage = new cc.FullImage(processContext, img);
                const w = fullImage.size[0];
                const h = fullImage.size[1];

                if (fullImage.textureSizeClipped) {
                    // TODO notify user in DOM
                    const m = processContext.imageSizeLimit;
                    console.warn(`image size ${w}x${h} exceeds the supported maximum ${m}x${m}`);
                }

                const minSubdivisions = 4;
                const maxSubdivisions = 128;
                const imgSize = Math.min(w, h);
                const maxCellSize = Math.round(imgSize / minSubdivisions);
                const minCellSize = Math.max(
                    cc.glyphPxMinimum,
                    Math.round(imgSize / maxSubdivisions)
                );

                subdivInput.disabled = false;
                // Negate to reverse the slider
                subdivInput.max = -minCellSize;
                subdivInput.min = -maxCellSize;

                const cellSize = computeCellSize(-subdivInput.valueAsNumber);
                const cellCount = getCellCount(cellSize, fullImage);

                updateCellSizePreview(cellSize, cellCount);

                image = new cc.Image(
                    processContext,
                    img,
                    cellCount
                );
            } else {
                image = null;
                fullImage = null;

                subdivInput.disabled = true;
            }
            imageDataDirty = true;
            refreshPreview();
        }

        function onImageUpload() {
            const userImage = document.getElementById("user-image");
            const imageUpload = document.getElementById("user-image-upload");
            const len = imageUpload.files.length;
            if (len == 1 && imageUpload.files[0].type.startsWith("image/")) {
                // TODO handle if image is too big
                const reader = new FileReader();
                reader.onload = (e) => {
                    userImage.src = e.target.result;
                    userImage.onload = () => setImage(userImage);
                    userImage.onerror = () => setImage(null);
                };
                reader.readAsDataURL(imageUpload.files[0]);
            } else {
                userImage.src = '';
                setImage(null);
                if (len > 1) {
                    console.error("unexpected file upload count " + len);
                }
            }
        }

        function onHoverCellSize(e) {
            if (fullImage) {
                // TODO inherit from style
                const gridColor = 'darkgray';
                const cellPreviewPortion = 0.8;
                const cellPreviewRadius = 0.68;
                const ctx = previewContext;
                const width = ctx.canvas.width;
                const height = ctx.canvas.height;
                const cellSize = computeCellSize(-e.target.valueAsNumber);
                const cellCount = getCellCount(cellSize, fullImage);
                const xStride = width/cellCount[0];
                const yStride = height/cellCount[1];
                const squareSize = Math.min(xStride, yStride) * cellPreviewPortion;
                const halfSquare = 0.5*squareSize;
                const radius = cellPreviewRadius * halfSquare;
                const [squareWidth, squareHeight] = (cellSize[1] > cellSize[0])
                    ? [squareSize, squareSize*(cellSize[1]/cellSize[0])]
                    : [squareSize*(cellSize[0]/cellSize[1]), squareSize];
                const squareHalfWidth = squareWidth * 0.5;
                const squareHalfHeight = squareHeight * 0.5;

                updateCellSizePreview(cellSize, cellCount);

                ctx.fillStyle = gridColor;
                ctx.clearRect(0, 0, width, height);
                ctx.beginPath();

                let col;
                for (let row = 0; row < cellCount[1]; row++) {
                    for (col = 0; col < cellCount[0]; col++) {
                        const x = (col+0.5)*xStride;
                        const y = (row+0.5)*yStride;
                        ctx.roundRect(
                            x-squareHalfWidth,
                            y-squareHalfHeight,
                            squareWidth,
                            squareHeight,
                            radius
                        );
                    }
                }

                ctx.fill();
            } else {
                console.error("cell size input hover without a set image");
            }
        }

        function onSetCellSize(e) {
            onImageUpload(); // TODO kind of hacky
            imageDataDirty = true;
            refreshPreview();
        }

        function getCellSize() {
            const subdivInput = document.getElementById("subdivisions-input");
            if (subdivInput.disabled) {
                console.error("request for unenabled cell size");
            }
            return computeCellSize(-subdivInput.valueAsNumber);
        }

        function computeCellSize(inputValue) {
            return [
                Math.round(inputValue),
                Math.round(2.0*inputValue)
            ];
        }

        function getCellCount(cellSize, fullImage) {
            return [
                Math.ceil(fullImage.size[0] / cellSize[0]),
                Math.ceil(fullImage.size[1] / cellSize[1])
            ];
        }

        function getPixelValuer() {
            const check = document.querySelector('input[name="value-choice"]:checked').value;
            switch (check) {
                case "lights":
                    return (rgba) => ((rgba[0]+rgba[1]+rgba[2])/3) * rgba[3];
                case "darks":
                    return (rgba) => (1-((rgba[0]+rgba[1]+rgba[2])/3)) * rgba[3];
                case null:
                    throw new Error("no value type checked at pixel valuation");
                default:
                    throw new Error(`unrecognized pixel valuation \"${check}\"`);
            }
        }

        function getLevelNodes() {
            return Array.from(document.getElementById("levels").children)
                .filter((element) => element.classList.contains("level"));
        }

        function getLevels() {
            return getLevelNodes().map((element) => ({
                range: element.querySelector("input[type=\"range\"].level-range"),
                glyphs: element.querySelector(".level-glyph-edit")
                    .querySelector(".level-glyph-edit-glyphs")
                    .value.split("").filter((c) => /\S/.test(c))
            }));
        }

        function getMasks() {
            return Array.from(document.getElementById("masks").children)
                .filter((element) => element.classList.contains("mask"))
                .map((element) => ({
                    colorNode: element.querySelector(".mask-color"),
                    rgb: cc.colorInputToRGB(element.querySelector(".mask-color"))
                }));
        }

        function onAddLevel() {
            const level = document.createElement("div");
            level.classList.add("level");
            level.append(document.getElementById("level-template")
                .content.cloneNode(true));

            const range = level.querySelector("input[type=\"range\"].level-range");
            const ranges = getLevels().map((l) => l.range);
            if (ranges.length > 0) {
                const lastRange = ranges.at(-1);
                const floor = Number(lastRange.value);
                const size = Math.min(Math.round((1-floor)*100), 100);

                range.style.inlineSize = `${size}%`;
                range.setAttribute("min", floor);
                range.value = 1.0;

                range.inputListener = (e) => {
                    const newFloor = Number(e.target.value);
                    const newSize = Math.min(Math.round((1.0 - newFloor)*100), 100);
                    range.style.inlineSize = `${newSize}%`;
                    range.setAttribute("min", newFloor);
                    range.dispatchEvent(new Event("cascade"));
                };
                lastRange.addEventListener("input", range.inputListener);
                lastRange.addEventListener("cascade", range.inputListener);
            } else {
                range.style.inlineSize = "100%";
                range.setAttribute("min", 0);
                range.value = 1.0;
            }

            const prevRange = ranges.at(-1);
            // TODO inherit from style
            const highlightColor = 'red';
            const hoverHighlightColor = 'pink';

            const highlightCells = (c) => ((e) => {
                if (imageMeans) cc.drawValueDots(
                    previewContext,
                    imageMeans,
                    getPixelValuer(),
                    null, [
                        prevRange?.valueAsNumber ?? 0,
                        e.target.valueAsNumber
                    ], c
                );
            });
            const clearCells = () => {
                if (imageMeans) cc.drawValueDots(previewContext, imageMeans, getPixelValuer())
            };
            range.addEventListener("input", highlightCells(highlightColor));
            range.addEventListener("mousedown", highlightCells(highlightColor));
            range.addEventListener("mouseenter", highlightCells(hoverHighlightColor));
            range.addEventListener("mouseup", highlightCells(hoverHighlightColor));
            range.addEventListener("mouseleave", clearCells);

            const selectButton = level.querySelector(".level-glyph-select");
            const editBox = level.querySelector(".level-glyph-edit");
            editBox.style.display = "none";
            editBox.querySelector(".level-glyph-edit-glyphs").disabled = true;
            const closeButton = editBox.querySelector(".level-glyph-edit-exit");
            closeButton.addEventListener("click", () => {
                editBox.style.display = "none";
                editBox.querySelector(".level-glyph-edit-glyphs").disabled = true;
            });
            selectButton.addEventListener("click", () => {
                Array.from(document.getElementById("levels").children)
                    .filter((element) => element.classList.contains("level"))
                    .map((element) => element.querySelector(".level-glyph-edit"))
                    .forEach((element) => { element.style.display = "none"; });
                editBox.style.display = "block";
                editBox.querySelector(".level-glyph-edit-glyphs").disabled = false;
            });

            document.getElementById("levels").appendChild(level);
        }

        function onRemoveLevel() {
            const levelNodes = getLevelNodes();

            if (levelNodes.length > 0) {
                const last = levelNodes.at(-1);
                const lastRange = last.querySelector("input[type=\"range\"].level-range");
                if (lastRange.inputListener) {
                    const secondToLast = levelNodes.at(-2);
                    if (secondToLast) {
                        secondToLast.querySelector("input[type=\"range\"].level-range")
                            .removeEventListener("input", lastRange.inputListener);
                    } else {
                        console.error("expected removed level node to have " +
                            "a parent with the matching input listener");
                    }
                } else if (levelNodes.length != 1) {
                    console.error("expected removed level node to have " +
                        "an input listener");
                }

                document.getElementById("levels").removeChild(last);
            }
        }

        function onChangeLevels() {
            if (getLevelNodes()?.length > 0) {
                removeLevel.disabled = false;
            } else {
                removeLevel.disabled = true;
            }
        }

        function onChangeValueChoice() {
            imageDataDirty = true;
            refreshPreview();
        }

        function onAddMask() {
            let color;
            switch (document.querySelector('input[name="value-choice"]:checked').value) {
                case "lights":
                    color = "#000000";
                    break;
                case "darks":
                    color = "#ffffff";
                    break;
                case null:
                    console.error("no value type checked at mask creation");
                    break;
                default:
                    console.error(`unrecognized pixel valuation \"${check}\"`);
                    break;
            }

            const mask = document.createElement("div");
            mask.classList.add("mask");
            mask.append(document.getElementById("mask-template")
                .content.cloneNode(true));

            const colorNode = mask.querySelector("input.mask-color");
            colorNode.addEventListener("change", onChangeMasks);
            if (color) colorNode.value = color;

            document.getElementById("masks").appendChild(mask);
            document.getElementById("remove-mask").disabled = false;

            onChangeMasks();
        }

        function onRemoveMask() {
            const masksNode = document.getElementById("masks");
            const masks = Array.from(masksNode.children).filter((element) =>
                element.classList.contains("mask"));
            if (masks.length > 0) {
                if (masks.length == 1) {
                    document.getElementById("remove-mask").disabled = true;
                }
                masksNode.removeChild(masks.at(-1));
            } else {
                console.error("invalid onRemoveMask() call for 0 mask elements");
            }

            onChangeMasks();
        }

        function onChangeMasks() {
            imageDataDirty = true;
            refreshPreview();
        }

        document.getElementById("user-image-upload").addEventListener("change", onImageUpload);
        document.getElementById("subdivisions-input").addEventListener("input", onHoverCellSize);
        document.getElementById("subdivisions-input").addEventListener("change", onSetCellSize);
        document.getElementById("process-output").addEventListener("click", refreshOutput);

        const addLevel = document.getElementById("add-level");
        const removeLevel = document.getElementById("remove-level");
        addLevel.addEventListener("click", onAddLevel);
        addLevel.addEventListener("click", onChangeLevels);
        removeLevel.addEventListener("click", onRemoveLevel);
        removeLevel.addEventListener("click", onChangeLevels);
        document.getElementById("add-mask").addEventListener("click", onAddMask);
        document.getElementById("remove-mask").addEventListener("click", onRemoveMask);
        document.querySelectorAll('input[name="value-choice"]')
            .forEach((node) =>
                node.addEventListener("change", onChangeValueChoice));

        let timeout = false;
        window.addEventListener("resize", function () {
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                previewContext.canvas.height = 1;
                previewContext.canvas.width = 1;
                refreshPreview()
            }, 5);
        });

        if (getMasks().length) {
            document.getElementById("remove-mask").disabled = false;
        } else {
            document.getElementById("remove-mask").disabled = true;
        }
        onChangeLevels();
        clearOutput();
        onImageUpload();
    </script>
    <canvas id="webgl-canvas" style="display: none;"></canvas>
    <canvas id="glyph-canvas" style="display: none;"></canvas>
    <div style="margin:2em;">
        <p>
            Thank you for trying out CookieCut!
            The software is not well-tested and may still have minor bugs.
            It's in a super early stage right now.
        </p>
        <p>
            I'm aware of the following issues on mobile browsers currently:
            <ul>
                <li>The center preview sometimes fails to load. If missing please, try refreshing or using a different image.</li>
                <li>The UI doesn't fit within the screen, and you have to scroll around horizontally.</li>
                <li>The cell level preview highlights don't go away after you stop dragging</li>
                <li>If your browser does not use a monospace font by default, the output will be unaligned</li>
            </ul>
        </p>
        <p>
            Because the UI is not very intuitive yet, here are instructions for use (sorry for the wall of text for now)
        </p>
        <ol>
            <li>Select a file below. It will be automatically processed, loaded, and shown in the center preview.</li>
            <li>The image is divided into a grid of cells. Each cell will be replaced with a single ASCII character. The cell size can be adjusted with the slider to the right.</li>
            <li>Each cell is assigned a strength based on its average color. The center preview draws larger circles for cells with higher strengths.</li>
            <li>You should choose whether the image should be processed as a dark foreground on light background, or light background on dark foreground, by selecting either "Value lights" or "Value darks". The cell preview in the center will immediately reflect the new strengths.</li>
            <li>Finally, we have choose what ASCII characters we want to assign to which cell strengths. This is done by dividing the cells into one or more levels, at the upper left.</li>
            <li>You can add and remove as many levels as you like. There must be at least one in order to create the output. A single level covering the entire range means "assign all cells to this level".</li>
            <li>We can separate out parts of the image into multiple levels. When adjusting the strength slider for a level, the cells of the image that are affected are highlighted in the center preview. When the image is processed, all cells within a level are assigned charcters from that level. If there are no characters, they will always be whitespace.</li>
            <li>To assign possible characters to a level, click "Edit level" and type in one or more characters. Whitespace will be ignored. If more than one character is assigned to a level, the character that best matches the rough pattern of that cell will be picked.</li>
            <li>The most common pattern is to leave the first (top-most) level empty, and adjust it until it covers everything we want to treat as background. Then, create more levels for however much detail you want to segment the image (3-8 generally). Make sure the last level is all the way to the right, unless you want to exclude some of the highest strength cells.</li>
            <li>You generally want to assign each level a bigger character or set of characters for higher strengths. For example, use ".", ":", "-", "=", etc.</li>
            <li>The histogram below the level sliders shows the frequencies of cell colors in the image, sorted left-to-right by strength. They may not be aligned correctly, but this should roughly indicate the strengths of different areas of the image.</li>
            <li>When you have at least one level with characters, you can press "Process" to write the output into the text box. In the future there will be options for font, spacing, and writing the output to images as well.</li>
            <li>There is no built background detection yet, so you might get the best results by masking out the image's background in another app before bringing it here.</li>
        </ol>
        <p>
            Some things that will be added in the future:
            <ol>
                <li>Visually intuitive UI</li>
                <li>Automatic default levels and immediate automatic output processing</li>
                <li>Manual output touch-ups</li>
                <li>Edge detection</li>
                <li>Font selection</li>
                <li>Output character colors and other post-processing</li>
                <li>Eyedrop mask color selection</li>
            </ol>
        </p>
    </div>
    <main class="cookiecut">
        <div class="preview-container">
            <canvas id="preview-canvas"></canvas>
        </div>
        <div class="image-selection-control">
            <div class="image-selection-control-header">
                <input type="file" id="user-image-upload" accept="image/*" />
            </div>
            <img id="user-image">
        </div>
        <div class="cookiecut-start-side">
            <div class="levels-control-container">
                <div id="levels-control">
                    <input type="button" id="remove-level" value="Remove level" />
                    <input type="button" id="add-level" value="Add level" />
                </div>
                <div id="levels">
                    <template id="level-template">
                        <input type="range" class="level-range" step="any" max="1" style="inline-size:100%;" />
                        <input type="button" class="level-glyph-select" value="Edit level" />
                        <div class="level-glyph-edit">
                            <input type="text" class="level-glyph-edit-glyphs" disabled />
                            <input type="button" class="level-glyph-edit-exit" value="Close level edit" />
                        </div>
                    </template>
                </div>
                <img id="level-histogram">
            </div>
        </div>
        <div class="cookiecut-end-side">
            <div class="subdiv-container">
                <div class="subdiv-display">
                    <span class="cell-size-width-display"></span>
                    <span class="cell-size-height-display"></span>
                    <span class="cell-count-width-display"></span>
                    <span class="cell-count-height-display"></span>
                </div>
                <input type="range" id="subdivisions-input" step="1" disabled />
            </div>
            <div class="value-choice-container">
                <input type="radio" id="value-lights-choice" name="value-choice" value="lights" checked />
                <label for="value-lights-choice">Value lights</label>
                <input type="radio" id="value-darks-choice" name="value-choice" value="darks" />
                <label for="value-darks-choice">Value darks</label>
            </div>
            <div class="masks-container">
                <div id="masks-control">
                    <input type="button" id="remove-mask" value="Remove mask" />
                    <input type="button" id="add-mask" value="Add mask" />
                </div>
                <div id="masks">
                    <template id="mask-template">
                        <input type="color" class="mask-color"/>
                    </template>
                </div>
            </div>
        </div>
    </main>
    <div class="output-container">
        <input type="button" id="process-output" value="Process" />
        <textarea id="output" readonly></textarea>
    </div>
</body>
</html>
